import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getServerSession } from "@/app/api/auth/[...nextauth]/utils";

interface FixVulnerabilityRequest {
  vulnerabilityId: string;
  fixOptions?: {
    branchPrefix?: string;
    createPullRequest?: boolean;
    prTitle?: string;
    prDescription?: string;
  };
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession();

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body: FixVulnerabilityRequest = await request.json();
    const { vulnerabilityId, fixOptions = {} } = body;

    if (!vulnerabilityId) {
      return NextResponse.json(
        { error: "Vulnerability ID is required" },
        { status: 400 }
      );
    }

    // Find the vulnerability and verify user access
    const vulnerability = await prisma.codeVulnerability.findFirst({
      where: {
        id: vulnerabilityId,
        scanJob: {
          userId: session.user.id,
        },
      },
      include: {
        scanJob: {
          include: {
            project: true,
          },
        },
      },
    });

    if (!vulnerability) {
      return NextResponse.json(
        { error: "Vulnerability not found or access denied" },
        { status: 404 }
      );
    }

    // Check if vulnerability category is fixable
    const FIXABLE_CATEGORIES = [
      'INJECTION',
      'AUTHENTICATION',
      'AUTHORIZATION', 
      'CRYPTOGRAPHY',
      'DATA_EXPOSURE',
      'INPUT_VALIDATION',
      'CONFIGURATION',
      'SESSION_MANAGEMENT'
    ];

    if (!FIXABLE_CATEGORIES.includes(vulnerability.category)) {
      return NextResponse.json(
        { error: `${vulnerability.category} vulnerabilities are not currently supported for automated fixing` },
        { status: 400 }
      );
    }

    // Check if there's already an active fix job for this vulnerability
    const existingFixJob = await prisma.fixJob.findFirst({
      where: {
        vulnerabilityId,
        status: {
          in: ['PENDING', 'IN_PROGRESS'],
        },
      },
    });

    if (existingFixJob) {
      return NextResponse.json(
        { 
          error: "A fix job is already in progress for this vulnerability",
          fixJobId: existingFixJob.id,
          status: existingFixJob.status
        },
        { status: 409 }
      );
    }

    // Extract scan job data to get repository information
    const scanJobData = vulnerability.scanJob.data as any;
    if (!scanJobData?.repo_url) {
      return NextResponse.json(
        { error: "Repository information not found in scan job" },
        { status: 400 }
      );
    }

    // Prepare fix job data
    const fixJobData = {
      vulnerabilityId: vulnerability.id,
      scanJobId: vulnerability.scanJobId,
      repositoryUrl: scanJobData.repo_url,
      branch: scanJobData.branch || 'main',
      commitSha: scanJobData.commit_sha || undefined,
      vulnerability: {
        title: vulnerability.title,
        filePath: vulnerability.filePath,
        startLine: vulnerability.startLine,
        endLine: vulnerability.endLine,
        codeSnippet: vulnerability.codeSnippet,
        severity: vulnerability.severity,
        category: vulnerability.category,
        description: vulnerability.description,
        recommendation: vulnerability.recommendation,
      },
      fixOptions: {
        createBranch: true,
        branchPrefix: fixOptions.branchPrefix || 'fix',
        createPullRequest: fixOptions.createPullRequest !== false,
        prTitle: fixOptions.prTitle || `Fix: ${vulnerability.title}`,
        prDescription: fixOptions.prDescription || `This PR automatically fixes a ${vulnerability.severity} severity ${vulnerability.category.toLowerCase()} vulnerability detected by Fortify security scan.`,
      },
    };

    // Create fix job in database
    const fixJob = await prisma.fixJob.create({
      data: {
        userId: session.user.id,
        type: 'VULNERABILITY_FIX',
        status: 'PENDING',
        vulnerabilityId: vulnerability.id,
        scanJobId: vulnerability.scanJobId,
        data: fixJobData,
      },
    });

    // TODO: Call fix-agent API to queue the fix job
    // For now, we'll just return the created fix job
    
    // In a complete implementation, this would make an HTTP request to fix-agent:
    // const fixAgentResponse = await fetch('http://fix-agent:8001/fix/vulnerability', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({ fixJobId: fixJob.id, ...fixJobData })
    // });

    console.log(`Created fix job ${fixJob.id} for vulnerability ${vulnerabilityId}`);

    return NextResponse.json({
      fixJobId: fixJob.id,
      message: "Fix job created successfully",
      status: fixJob.status,
      vulnerability: {
        id: vulnerability.id,
        title: vulnerability.title,
        category: vulnerability.category,
        severity: vulnerability.severity,
      },
    });

  } catch (error) {
    console.error("Error creating fix job:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}