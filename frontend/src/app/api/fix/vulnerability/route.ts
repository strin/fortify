import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getServerSession } from "@/app/api/auth/[...nextauth]/utils";

// Queue fix job by calling scan-agent API
async function queueFixJob(fixJobId: string, fixJobData: any) {
  const scanAgentUrl = process.env.SCAN_AGENT_URL || "http://localhost:8000";
  const requestBody = {
    fixJobId: fixJobId,
    ...fixJobData,
  };

  console.log(
    `[Fix API] Calling scan-agent at: ${scanAgentUrl}/fix/vulnerability`
  );
  console.log(`[Fix API] Request body:`, JSON.stringify(requestBody, null, 2));

  try {
    const response = await fetch(`${scanAgentUrl}/fix/vulnerability`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    console.log(
      `[Fix API] Response status: ${response.status} ${response.statusText}`
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[Fix API] Error response: ${errorText}`);
      throw new Error(`Failed to queue fix job: ${errorText}`);
    }

    const result = await response.json();
    console.log(`[Fix API] Success response:`, result);
    return result;
  } catch (error) {
    console.error(`[Fix API] Request failed:`, error);
    throw error;
  }
}

interface FixVulnerabilityRequest {
  vulnerabilityId: string;
  fixOptions?: {
    branchPrefix?: string;
    createPullRequest?: boolean;
    prTitle?: string;
    prDescription?: string;
  };
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession();

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body: FixVulnerabilityRequest = await request.json();
    const { vulnerabilityId, fixOptions = {} } = body;

    if (!vulnerabilityId) {
      return NextResponse.json(
        { error: "Vulnerability ID is required" },
        { status: 400 }
      );
    }

    // Find the vulnerability and verify user access
    const vulnerability = await prisma.codeVulnerability.findFirst({
      where: {
        id: vulnerabilityId,
        scanJob: {
          userId: session.user.id,
        },
      },
      include: {
        scanJob: {
          include: {
            project: true,
          },
        },
      },
    });

    if (!vulnerability) {
      return NextResponse.json(
        { error: "Vulnerability not found or access denied" },
        { status: 404 }
      );
    }

    // Check if vulnerability category is fixable
    const FIXABLE_CATEGORIES = [
      "INJECTION",
      "AUTHENTICATION",
      "AUTHORIZATION",
      "CRYPTOGRAPHY",
      "DATA_EXPOSURE",
      "INPUT_VALIDATION",
      "CONFIGURATION",
      "SESSION_MANAGEMENT",
    ];

    if (!FIXABLE_CATEGORIES.includes(vulnerability.category)) {
      return NextResponse.json(
        {
          error: `${vulnerability.category} vulnerabilities are not currently supported for automated fixing`,
        },
        { status: 400 }
      );
    }

    // Check if there's already an active fix job for this vulnerability
    const existingFixJob = await prisma.fixJob.findFirst({
      where: {
        vulnerabilityId,
        status: {
          in: ["PENDING", "IN_PROGRESS"],
        },
      },
    });

    if (existingFixJob) {
      return NextResponse.json(
        {
          error: "A fix job is already in progress for this vulnerability",
          fixJobId: existingFixJob.id,
          status: existingFixJob.status,
        },
        { status: 409 }
      );
    }

    // Extract scan job data to get repository information
    const scanJobData = vulnerability.scanJob.data as any;
    if (!scanJobData?.repo_url) {
      return NextResponse.json(
        { error: "Repository information not found in scan job" },
        { status: 400 }
      );
    }

    // Prepare fix job data
    const fixJobData = {
      vulnerabilityId: vulnerability.id,
      scanJobId: vulnerability.scanJobId,
      repositoryUrl: scanJobData.repo_url,
      branch: scanJobData.branch || "main",
      commitSha: scanJobData.commit_sha || undefined,
      vulnerability: {
        title: vulnerability.title,
        filePath: vulnerability.filePath,
        startLine: vulnerability.startLine,
        endLine: vulnerability.endLine,
        codeSnippet: vulnerability.codeSnippet,
        severity: vulnerability.severity,
        category: vulnerability.category,
        description: vulnerability.description,
        recommendation: vulnerability.recommendation,
      },
      fixOptions: {
        createBranch: true,
        branchPrefix: fixOptions.branchPrefix || "fix",
        createPullRequest: fixOptions.createPullRequest !== false,
        prTitle: fixOptions.prTitle || `Fix: ${vulnerability.title}`,
        prDescription:
          fixOptions.prDescription ||
          `This PR automatically fixes a ${
            vulnerability.severity
          } severity ${vulnerability.category.toLowerCase()} vulnerability detected by Fortify security scan.`,
      },
    };

    // Create fix job in database
    const fixJob = await prisma.fixJob.create({
      data: {
        userId: session.user.id,
        status: "PENDING",
        vulnerabilityId: vulnerability.id,
        data: fixJobData,
      },
    });

    // Queue the fix job for processing by the fix-agent worker
    console.log(`[Fix API] About to queue fix job ${fixJob.id}`);
    try {
      const queueResult = await queueFixJob(fixJob.id, fixJobData);
      console.log(
        `[Fix API] Successfully queued fix job ${fixJob.id}:`,
        queueResult
      );
    } catch (queueError) {
      console.error(
        `[Fix API] Failed to queue fix job ${fixJob.id}:`,
        queueError
      );
      // Note: We don't fail the request here since the job was created in the database
      // The job can be retried manually or picked up later
    }

    console.log(
      `Created fix job ${fixJob.id} for vulnerability ${vulnerabilityId}`
    );

    return NextResponse.json({
      fixJobId: fixJob.id,
      message: "Fix job created successfully",
      status: fixJob.status,
      vulnerability: {
        id: vulnerability.id,
        title: vulnerability.title,
        category: vulnerability.category,
        severity: vulnerability.severity,
      },
    });
  } catch (error) {
    console.error("Error creating fix job:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
