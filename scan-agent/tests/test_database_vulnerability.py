"""
Test database operations for CodeVulnerability creation and management.

This test module demonstrates and validates:
1. Creating ScanJob records
2. Creating CodeVulnerability records
3. Querying relationships between ScanJob and CodeVulnerability
4. Database utility functions
"""

import pytest
import pytest_asyncio
import json
from datetime import datetime
from typing import Dict, Any

from scan_agent.utils import (
    init_database,
    close_database,
    get_db,
    check_database_health
)


class TestDatabaseVulnerability:
    """Test class for database vulnerability operations."""

    @pytest_asyncio.fixture(autouse=True)
    async def setup_database(self):
        """Setup database connection for each test."""
        await init_database()
        
        # Verify database health
        assert await check_database_health(), "Database should be healthy"
        
        yield
        
        await close_database()

    def create_sample_scan_job_data(self) -> Dict[str, Any]:
        """Create sample scan job data."""
        return {
            "repository_url": "https://github.com/test/vulnerable-app",
            "branch": "main",
            "commit_sha": "test123abc456",
            "scan_config": {
                "include_patterns": ["*.py", "*.js", "*.ts"],
                "exclude_patterns": ["node_modules/**", "*.test.*"],
                "max_file_size": 1000000
            },
            "webhook_config": {
                "url": "https://api.test.com/webhook",
                "secret": "test_webhook_secret"
            }
        }

    def create_sample_vulnerability_data(self) -> Dict[str, Any]:
        """Create sample vulnerability data."""
        return {
            "title": "SQL Injection Vulnerability",
            "description": "The application constructs SQL queries using string concatenation without proper sanitization.",
            "severity": "HIGH",
            "category": "INJECTION",
            "filePath": "src/auth/login.py",
            "startLine": 45,
            "endLine": 47,
            "codeSnippet": '''def authenticate_user(username, password):
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    return execute_query(query)''',
            "recommendation": "Use parameterized queries or prepared statements to prevent SQL injection.",
            "metadata": {
                "cwe": "CWE-89",
                "owasp": "A03:2021 – Injection",
                "confidence": 0.95,
                "impact": "High - Could lead to unauthorized data access",
                "exploitability": "Easy - Basic SQL injection techniques"
            }
        }

    @pytest.mark.asyncio
    async def test_database_health_check(self):
        """Test database health check functionality."""
        is_healthy = await check_database_health()
        assert is_healthy, "Database should be healthy"

    @pytest.mark.asyncio
    async def test_create_scan_job(self):
        """Test creating a scan job."""
        db = await get_db()
        scan_job_data = self.create_sample_scan_job_data()
        
        scan_job = await db.scanjob.create(
            data={
                "repoUrl": scan_job_data["repository_url"],
                "repoOwner": "test",
                "repoName": "vulnerable-app",
                "branch": scan_job_data["branch"],
                "commitSha": scan_job_data["commit_sha"],
                "type": "SCAN_REPO",
                "status": "COMPLETED",
                "data": json.dumps(scan_job_data),
                "result": json.dumps({
                    "scan_summary": {
                        "files_scanned": 25,
                        "vulnerabilities_found": 1,
                        "scan_duration": "00:02:35"
                    }
                }),
                "startedAt": datetime.now(),
                "finishedAt": datetime.now(),
                "filesScanned": 25,
                "vulnerabilitiesFound": 1,
                "sourceBytes": 125000
            }
        )
        
        assert scan_job.id is not None
        assert scan_job.repoUrl == scan_job_data["repository_url"]
        assert scan_job.status == "COMPLETED"
        assert scan_job.filesScanned == 25
        assert scan_job.vulnerabilitiesFound == 1
        
        # Cleanup
        await db.scanjob.delete(where={"id": scan_job.id})

    @pytest.mark.asyncio
    async def test_create_vulnerability(self):
        """Test creating a vulnerability with associated scan job."""
        db = await get_db()
        
        # First create a scan job
        scan_job_data = self.create_sample_scan_job_data()
        scan_job = await db.scanjob.create(
            data={
                "repoUrl": scan_job_data["repository_url"],
                "repoOwner": "test",
                "repoName": "vulnerable-app",
                "branch": scan_job_data["branch"],
                "commitSha": scan_job_data["commit_sha"],
                "type": "SCAN_REPO",
                "status": "COMPLETED",
                "data": json.dumps(scan_job_data),
                "filesScanned": 1,
                "vulnerabilitiesFound": 1
            }
        )
        
        # Create vulnerability
        vuln_data = self.create_sample_vulnerability_data()
        vulnerability = await db.codevulnerability.create(
            data={
                "scanJobId": scan_job.id,
                "title": vuln_data["title"],
                "description": vuln_data["description"],
                "severity": vuln_data["severity"],
                "category": vuln_data["category"],
                "filePath": vuln_data["filePath"],
                "startLine": vuln_data["startLine"],
                "endLine": vuln_data["endLine"],
                "codeSnippet": vuln_data["codeSnippet"],
                "recommendation": vuln_data["recommendation"],
                "metadata": vuln_data["metadata"]
            }
        )
        
        assert vulnerability.id is not None
        assert vulnerability.scanJobId == scan_job.id
        assert vulnerability.title == vuln_data["title"]
        assert vulnerability.severity == vuln_data["severity"]
        assert vulnerability.category == vuln_data["category"]
        assert vulnerability.filePath == vuln_data["filePath"]
        assert vulnerability.startLine == vuln_data["startLine"]
        assert vulnerability.metadata == vuln_data["metadata"]
        
        # Cleanup
        await db.codevulnerability.delete(where={"id": vulnerability.id})
        await db.scanjob.delete(where={"id": scan_job.id})

    @pytest.mark.asyncio
    async def test_query_scan_job_with_vulnerabilities(self):
        """Test querying scan job with its associated vulnerabilities."""
        db = await get_db()
        
        # Create scan job
        scan_job_data = self.create_sample_scan_job_data()
        scan_job = await db.scanjob.create(
            data={
                "repoUrl": scan_job_data["repository_url"],
                "repoOwner": "test",
                "repoName": "vulnerable-app",
                "branch": scan_job_data["branch"],
                "commitSha": scan_job_data["commit_sha"],
                "type": "SCAN_REPO",
                "status": "COMPLETED",
                "data": json.dumps(scan_job_data),
                "filesScanned": 2,
                "vulnerabilitiesFound": 2
            }
        )
        
        # Create multiple vulnerabilities
        vuln_data_1 = self.create_sample_vulnerability_data()
        vuln_data_2 = self.create_sample_vulnerability_data()
        vuln_data_2["title"] = "Cross-Site Scripting (XSS) Vulnerability"
        vuln_data_2["category"] = "INPUT_VALIDATION"
        vuln_data_2["filePath"] = "src/web/views.py"
        
        vulnerability_1 = await db.codevulnerability.create(
            data={
                "scanJobId": scan_job.id,
                "title": vuln_data_1["title"],
                "description": vuln_data_1["description"],
                "severity": vuln_data_1["severity"],
                "category": vuln_data_1["category"],
                "filePath": vuln_data_1["filePath"],
                "startLine": vuln_data_1["startLine"],
                "codeSnippet": vuln_data_1["codeSnippet"],
                "recommendation": vuln_data_1["recommendation"],
                "metadata": vuln_data_1["metadata"]
            }
        )
        
        vulnerability_2 = await db.codevulnerability.create(
            data={
                "scanJobId": scan_job.id,
                "title": vuln_data_2["title"],
                "description": vuln_data_2["description"],
                "severity": vuln_data_2["severity"],
                "category": vuln_data_2["category"],
                "filePath": vuln_data_2["filePath"],
                "startLine": vuln_data_2["startLine"],
                "codeSnippet": vuln_data_2["codeSnippet"],
                "recommendation": vuln_data_2["recommendation"],
                "metadata": vuln_data_2["metadata"]
            }
        )
        
        # Query scan job with vulnerabilities
        scan_job_with_vulns = await db.scanjob.find_unique(
            where={"id": scan_job.id},
            include={"vulnerabilities": True}
        )
        
        assert scan_job_with_vulns is not None
        assert len(scan_job_with_vulns.vulnerabilities) == 2
        
        # Verify vulnerability details
        vuln_titles = [v.title for v in scan_job_with_vulns.vulnerabilities]
        assert vuln_data_1["title"] in vuln_titles
        assert vuln_data_2["title"] in vuln_titles
        
        # Cleanup
        await db.codevulnerability.delete(where={"id": vulnerability_1.id})
        await db.codevulnerability.delete(where={"id": vulnerability_2.id})
        await db.scanjob.delete(where={"id": scan_job.id})

    @pytest.mark.asyncio
    async def test_query_vulnerability_with_scan_job(self):
        """Test querying vulnerability with its associated scan job."""
        db = await get_db()
        
        # Create scan job
        scan_job_data = self.create_sample_scan_job_data()
        scan_job = await db.scanjob.create(
            data={
                "repoUrl": scan_job_data["repository_url"],
                "repoOwner": "test",
                "repoName": "vulnerable-app",
                "branch": scan_job_data["branch"],
                "commitSha": scan_job_data["commit_sha"],
                "type": "SCAN_REPO",
                "status": "COMPLETED",
                "data": json.dumps(scan_job_data),
                "filesScanned": 1,
                "vulnerabilitiesFound": 1
            }
        )
        
        # Create vulnerability
        vuln_data = self.create_sample_vulnerability_data()
        vulnerability = await db.codevulnerability.create(
            data={
                "scanJobId": scan_job.id,
                "title": vuln_data["title"],
                "description": vuln_data["description"],
                "severity": vuln_data["severity"],
                "category": vuln_data["category"],
                "filePath": vuln_data["filePath"],
                "startLine": vuln_data["startLine"],
                "codeSnippet": vuln_data["codeSnippet"],
                "recommendation": vuln_data["recommendation"],
                "metadata": vuln_data["metadata"]
            }
        )
        
        # Query vulnerability with scan job
        vuln_with_scan_job = await db.codevulnerability.find_unique(
            where={"id": vulnerability.id},
            include={"scanJob": True}
        )
        
        assert vuln_with_scan_job is not None
        assert vuln_with_scan_job.scanJob is not None
        assert vuln_with_scan_job.scanJob.id == scan_job.id
        assert vuln_with_scan_job.scanJob.repoUrl == scan_job_data["repository_url"]
        
        # Cleanup
        await db.codevulnerability.delete(where={"id": vulnerability.id})
        await db.scanjob.delete(where={"id": scan_job.id})

    @pytest.mark.asyncio
    @pytest.mark.parametrize("severity", ["INFO", "LOW", "MEDIUM", "HIGH", "CRITICAL"])
    async def test_vulnerability_severity_levels(self, severity):
        """Test creating vulnerabilities with different severity levels."""
        db = await get_db()
        
        # Create scan job
        scan_job_data = self.create_sample_scan_job_data()
        scan_job = await db.scanjob.create(
            data={
                "repoUrl": scan_job_data["repository_url"],
                "repoOwner": "test",
                "repoName": "vulnerable-app",
                "branch": scan_job_data["branch"],
                "commitSha": scan_job_data["commit_sha"],
                "type": "SCAN_REPO",
                "status": "COMPLETED",
                "data": json.dumps(scan_job_data),
                "filesScanned": 1,
                "vulnerabilitiesFound": 1
            }
        )
        
        # Create vulnerability with specific severity
        vuln_data = self.create_sample_vulnerability_data()
        vuln_data["severity"] = severity
        
        vulnerability = await db.codevulnerability.create(
            data={
                "scanJobId": scan_job.id,
                "title": f"{severity} Severity Test Vulnerability",
                "description": vuln_data["description"],
                "severity": severity,
                "category": vuln_data["category"],
                "filePath": vuln_data["filePath"],
                "startLine": vuln_data["startLine"],
                "codeSnippet": vuln_data["codeSnippet"],
                "recommendation": vuln_data["recommendation"],
                "metadata": vuln_data["metadata"]
            }
        )
        
        assert vulnerability.severity == severity
        
        # Cleanup
        await db.codevulnerability.delete(where={"id": vulnerability.id})
        await db.scanjob.delete(where={"id": scan_job.id})


# Standalone test function for manual execution
async def create_test_vulnerability_standalone():
    """
    Standalone function to create test vulnerability data.
    Can be run independently for manual testing.
    """
    print("Creating test vulnerability data...")
    
    try:
        await init_database()
        
        if not await check_database_health():
            print("❌ Database health check failed!")
            return
        
        print("✅ Database connection established and healthy")
        
        db = await get_db()
        
        # Create test data
        scan_job_data = {
            "repository_url": "https://github.com/example/test-repo",
            "branch": "main",
            "commit_sha": "standalone_test_123",
            "scan_config": {"test": True}
        }
        
        scan_job = await db.scanjob.create(
            data={
                "repoUrl": scan_job_data["repository_url"],
                "repoOwner": "example",
                "repoName": "test-repo",
                "branch": scan_job_data["branch"],
                "commitSha": scan_job_data["commit_sha"],
                "type": "SCAN_REPO",
                "status": "COMPLETED",
                "data": json.dumps(scan_job_data),
                "filesScanned": 1,
                "vulnerabilitiesFound": 1
            }
        )
        
        vulnerability = await db.codevulnerability.create(
            data={
                "scanJobId": scan_job.id,
                "title": "Test SQL Injection",
                "description": "Test vulnerability for demonstration",
                "severity": "HIGH",
                "category": "INJECTION",
                "filePath": "test/example.py",
                "startLine": 10,
                "codeSnippet": "query = f'SELECT * FROM users WHERE id={user_id}'",
                "recommendation": "Use parameterized queries",
                "metadata": {"test": True}
            }
        )
        
        print(f"✅ Created scan job: {scan_job.id}")
        print(f"✅ Created vulnerability: {vulnerability.id}")
        
        # Query and display
        result = await db.scanjob.find_unique(
            where={"id": scan_job.id},
            include={"vulnerabilities": True}
        )
        
        print(f"📊 Scan Job: {result.repoUrl}")
        print(f"📊 Vulnerabilities: {len(result.vulnerabilities)}")
        for vuln in result.vulnerabilities:
            print(f"  - {vuln.title} ({vuln.severity})")
        
        # Ask for cleanup
        cleanup = input("\n🗑️  Clean up test data? (y/N): ").strip().lower()
        if cleanup == 'y':
            await db.codevulnerability.delete(where={"id": vulnerability.id})
            await db.scanjob.delete(where={"id": scan_job.id})
            print("✅ Test data cleaned up")
        else:
            print(f"💾 Test data preserved - Scan Job ID: {scan_job.id}")
        
    except Exception as e:
        print(f"❌ Error: {e}")
        raise
    finally:
        await close_database()


if __name__ == "__main__":
    import asyncio
    asyncio.run(create_test_vulnerability_standalone())
